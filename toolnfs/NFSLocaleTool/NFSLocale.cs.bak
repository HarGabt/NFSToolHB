using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace NFSLocaleTool
{
    internal class NFSLocale
    {
        //all offsets without 8 bytes
        public uint Signature = 0x039000;
        public int FileSize { get; set; }
        public int EntriesNum { get; set; }
        public int TableOffset { get; set; }
        public int DataOffset { get; set; }
        public string Type { get; set; }
        List<Entry> Entries { get; set; }

        public void ExtractText(string outputFile)
        {
            List<string> text = new List<string>();
            foreach (Entry entry in Entries)
            {
                text.Add($"{entry.String.Replace("\n", "¬")}");
            }
            File.WriteAllLines(outputFile, text.ToArray());
        }

        public void WriteFromText(string textFile, string outputChunk, string idsFile)
        {
            string[] text = File.ReadAllLines(textFile);
            string[] ids_ = File.ReadAllLines(idsFile);
            if(text.Length != ids_.Length)
            {
                Console.WriteLine($"Несоответствие кол-ва строк в файле {Path.GetFileName(textFile)} к ID в файле {Path.GetFileName(idsFile)}");
                Console.WriteLine($"{text.Length}/{ids_.Length}");
                return;
            }
            uint[] ids = new uint[text.Length];
            uint[] offsets = new uint[text.Length];
            for(int i = 0; i < ids_.Length; i++)
            {
                ids[i] = UInt32.Parse(ids_[i], System.Globalization.NumberStyles.HexNumber);
            }
            using(BinaryWriter writer = new BinaryWriter(File.Create(outputChunk)))
            {
                writer.Write(Signature);
                writer.Write(0); //skip filesize
                writer.Write(text.Length); //listSize
                writer.Write(140); //table offset dataOffset
                int textStart = (text.Length * 8) + 0x8C;//calculate text offset stringsOffset 8-9
                writer.Write(textStart);
                writer.Write(Encoding.UTF8.GetBytes("Default"));

                writer.BaseStream.Position = textStart + 8; // start text
                for(int i = 0; i < text.Length; i++)
                {
                    offsets[i] = (uint)((writer.BaseStream.Position - textStart) - 8);
                    writer.Write(NFSEncoder(text[i].Replace("\"\"", "\"")));
                    writer.Write(new byte()); //null term
                }
                writer.BaseStream.Position = 0x94;
                for (int i = 0; i < text.Length; i++)
                {
                    writer.Write(ids[i]);
                    writer.Write(offsets[i]);
                }

                writer.BaseStream.Position = 4;
                writer.Write((uint)(writer.BaseStream.Length - 8));
            }
        }
        public void Read(string file)
        {
            using(BinaryReader reader = new BinaryReader(File.OpenRead(file)))
            {
                if (reader.ReadUInt32() != Signature)
                    throw new Exception("Unknown file");
                FileSize = reader.ReadInt32();
                EntriesNum = reader.ReadInt32();
                TableOffset = reader.ReadInt32();
                DataOffset = reader.ReadInt32();
                Type = Utils.ReadString(reader, Encoding.UTF8);

                Entries = new List<Entry>();
                reader.BaseStream.Position = TableOffset + 8;
                for(int i = 0; i < EntriesNum; i++)
                {
                    Entries.Add(new Entry()
                    {
                        Id = reader.ReadUInt32(),
                        Offset = reader.ReadInt32() + DataOffset + 8
                    });
                }
                for(int i = 0; i < EntriesNum; i++)
                {
                    Entry entry = Entries[i];
                    reader.BaseStream.Position = entry.Offset;
                    entry.String = NFSDecoder(Utils.ReadNullTerminatedArray(reader));
                    Entries[i] = entry;
                }

                File.WriteAllLines(file + ".ids", Entries.Select(i => i.Id.ToString("X8")));
            }
        }

        private byte[] NFSEncoder(string text)
        {
            List<byte> result = new List<byte>();
            for(int i = 0; i < text.Length; i++)
            {
                switch (text[i])
                {
                    case 'А': result.Add(0xc0); break;
                    case 'Б': result.Add(0xc2); break;
                    case 'В': result.Add(0x90); break;
                    case 'Г': result.Add(0x91); break;
                    case 'Д': result.Add(0xc3); break;
                    case 'Е': result.Add(0xc4); break;
                    case 'Ё': result.Add(0x9c); break;
                    case 'Ж': result.Add(0xc5); break;
                    case 'З': result.Add(0xc6); break;
                    case 'И': result.Add(0xc7); break;
                    case 'Й': result.Add(0x9e); break;
                    case 'К': result.Add(0xc9); break;
                    case 'Л': result.Add(0xca); break;
                    case 'М': result.Add(0xcb); break;
                    case 'Н': result.Add(0x92); break;
                    case 'О': result.Add(0xcc); break;
                    case 'П': result.Add(0xce); break;
                    case 'Р': result.Add(0xcf); break;
                    case 'С': result.Add(0xd0); break;
                    case 'Т': result.Add(0xd1); break;
                    case 'У': result.Add(0xd2); break;
                    case 'Ф': result.Add(0xd3); break;
                    case 'Х': result.Add(0xd4); break;
                    case 'Ц': result.Add(0xd5); break;
                    case 'Ч': result.Add(0xd6); break;
                    case 'Ш': result.Add(0xd7); break;
                    case 'Щ': result.Add(0xd8); break;
                    case 'Ъ': result.Add(0xd9); break;
                    case 'Ы': result.Add(0xda); break;
                    case 'Ь': result.Add(0xdb); break;
                    case 'Э': result.Add(0xdd); break;
                    case 'Ю': result.Add(0xde); break;
                    case 'Я': result.Add(0xdf); break;
                    case 'а': result.Add(0x93); break;
                    case 'б': result.Add(0xe2); break;
                    case 'в': result.Add(0x8a); break;
                    case 'г': result.Add(0xe3); break;
                    case 'д': result.Add(0x94); break;
                    case 'е': result.Add(0x8b); break;
                    case 'ё': result.Add(0x9b); break;
                    case 'ж': result.Add(0xe4); break;
                    case 'з': result.Add(0xe5); break;
                    case 'и': result.Add(0x8c); break;
                    case 'й': result.Add(0xe6); break;
                    case 'к': result.Add(0xeb); break;
                    case 'л': result.Add(0x95); break;
                    case 'м': result.Add(0xec); break;
                    case 'н': result.Add(0x96); break;
                    case 'о': result.Add(0x89); break;
                    case 'п': result.Add(0x97); break;
                    case 'р': result.Add(0x8d); break;
                    case 'с': result.Add(0x98); break;
                    case 'т': result.Add(0xee); break;
                    case 'у': result.Add(0xf0); break;
                    case 'ф': result.Add(0xf2); break;
                    case 'х': result.Add(0xf4); break;
                    case 'ц': result.Add(0xf5); break;
                    case 'ч': result.Add(0xf7); break;
                    case 'ш': result.Add(0xf8); break;
                    case 'щ': result.Add(0xf9); break;
                    case 'ъ': result.Add(0xfb); break;
                    case 'ы': result.Add(0xfd); break;
                    case 'ь': result.Add(0xfe); break;
                    case 'э': result.Add(0xff); break;
                    case 'ю': result.Add(0xbf); break;
                    case 'я': result.Add(0xaf); break;
                    case '’': result.Add(0x81); break;
                    case '…': result.Add(0x82); break;
                    case '“': result.Add(0x83); break;
                    case '”': result.Add(0x84); break;
                    case '•': result.Add(0x85); break;
                    case '‘': result.Add(0x86); break;
                    case '™': result.Add(0x87); break;
                    case '–': result.Add(0x88); break;
                    case '—': result.Add(0x8e); break;
                    case 'ł': result.Add(0x8f); break;
                    case 'ї': result.Add(0x99); break;
                    case '': result.Add(0x9a); break;
                    case ' ': result.Add(0xa0); break;
                    case '£': result.Add(0xa3); break;
                    case '©': result.Add(0xa9); break;
                    case '®': result.Add(0xae); break;
                    case '°': result.Add(0xb0); break;
                    case '´': result.Add(0xb4); break;
                    case '·': result.Add(0xb7); break;
                    case '¼': result.Add(0xbc); break;
                    case 'Á': result.Add(0xc1); break;
                    case 'Í': result.Add(0xcd); break;
                    case 'Ü': result.Add(0xdc); break;
                    case 'à': result.Add(0xe0); break;
                    case 'á': result.Add(0xe1); break;
                    case 'ç': result.Add(0xe7); break;
                    case 'è': result.Add(0xe8); break;
                    case 'é': result.Add(0xe9); break;
                    case 'ê': result.Add(0xea); break;
                    case 'í': result.Add(0xed); break;
                    case 'ï': result.Add(0xef); break;
                    case 'ñ': result.Add(0xf1); break;
                    case 'ó': result.Add(0xf3); break;
                    case 'ö': result.Add(0xf6); break;
                    case 'ú': result.Add(0xfa); break;
                    case 'ü': result.Add(0xfc); break;
                    case '«': result.Add(0xab); break;
                    case '»': result.Add(0xbb); break;
                    case '¬': result.Add(0x0a); break;
                    default: result.Add((byte)text[i]); break;
                }
            }
            return result.ToArray();
        }

        private string NFSDecoder(byte[] data)
        {
            string result = "";
            for(int i = 0; i < data.Length; i++)
            {
                switch (data[i])
                {
                    case 0xc0: result += "А"; break;
                    case 0xc2: result += "Б"; break;
                    case 0x90: result += "В"; break;
                    case 0x91: result += "Г"; break;
                    case 0xc3: result += "Д"; break;
                    case 0xc4: result += "Е"; break;
                    case 0x9c: result += "Ё"; break;
                    case 0xc5: result += "Ж"; break;
                    case 0xc6: result += "З"; break;
                    case 0xc7: result += "И"; break;
                    case 0x9e: result += "Й"; break;
                    case 0xc9: result += "К"; break;
                    case 0xca: result += "Л"; break;
                    case 0xcb: result += "М"; break;
                    case 0x92: result += "Н"; break;
                    case 0xcc: result += "О"; break;
                    case 0xce: result += "П"; break;
                    case 0xcf: result += "Р"; break;
                    case 0xd0: result += "С"; break;
                    case 0xd1: result += "Т"; break;
                    case 0xd2: result += "У"; break;
                    case 0xd3: result += "Ф"; break;
                    case 0xd4: result += "Х"; break;
                    case 0xd5: result += "Ц"; break;
                    case 0xd6: result += "Ч"; break;
                    case 0xd7: result += "Ш"; break;
                    case 0xd8: result += "Щ"; break;
                    case 0xd9: result += "Ъ"; break;
                    case 0xda: result += "Ы"; break;
                    case 0xdb: result += "Ь"; break;
                    case 0xdd: result += "Э"; break;
                    case 0xde: result += "Ю"; break;
                    case 0xdf: result += "Я"; break;
                    case 0x93: result += "а"; break;
                    case 0xe2: result += "б"; break;
                    case 0x8a: result += "в"; break;
                    case 0xe3: result += "г"; break;
                    case 0x94: result += "д"; break;
                    case 0x8b: result += "е"; break;
                    case 0x9b: result += "ё"; break;
                    case 0xe4: result += "ж"; break;
                    case 0xe5: result += "з"; break;
                    case 0x8c: result += "и"; break;
                    case 0xe6: result += "й"; break;
                    case 0xeb: result += "к"; break;
                    case 0x95: result += "л"; break;
                    case 0xec: result += "м"; break;
                    case 0x96: result += "н"; break;
                    case 0x89: result += "о"; break;
                    case 0x97: result += "п"; break;
                    case 0x8d: result += "р"; break;
                    case 0x98: result += "с"; break;
                    case 0xee: result += "т"; break;
                    case 0xf0: result += "у"; break;
                    case 0xf2: result += "ф"; break;
                    case 0xf4: result += "х"; break;
                    case 0xf5: result += "ц"; break;
                    case 0xf7: result += "ч"; break;
                    case 0xf8: result += "ш"; break;
                    case 0xf9: result += "щ"; break;
                    case 0xfb: result += "ъ"; break;
                    case 0xfd: result += "ы"; break;
                    case 0xfe: result += "ь"; break;
                    case 0xff: result += "э"; break;
                    case 0xbf: result += "ю"; break;
                    case 0xaf: result += "я"; break;
                    case 0x81: result += '’'; break;
                    case 0x82: result += '…'; break;
                    case 0x83: result += '“'; break;
                    case 0x84: result += '”'; break;
                    case 0x85: result += '•'; break;
                    case 0x86: result += '‘'; break;
                    case 0x87: result += '™'; break;
                    case 0x88: result += '–'; break;
                    case 0x8e: result += '—'; break;
                    case 0x8f: result += 'ł'; break;
                    case 0x99: result += 'ї'; break;
                    case 0x9a: result += ''; break;
                    case 0xa0: result += ' '; break;
                    case 0xa3: result += '£'; break;
                    case 0xa9: result += '©'; break;
                    case 0xae: result += '®'; break;
                    case 0xb0: result += '°'; break;
                    case 0xb4: result += '´'; break;
                    case 0xb7: result += '·'; break;
                    case 0xbc: result += '¼'; break;
                    case 0xc1: result += 'Á'; break;
                    case 0xcd: result += 'Í'; break;
                    case 0xdc: result += 'Ü'; break;
                    case 0xe0: result += 'à'; break;
                    case 0xe1: result += 'á'; break;
                    case 0xe7: result += 'ç'; break;
                    case 0xe8: result += 'è'; break;
                    case 0xe9: result += 'é'; break;
                    case 0xea: result += 'ê'; break;
                    case 0xed: result += 'í'; break;
                    case 0xef: result += 'ï'; break;
                    case 0xf1: result += 'ñ'; break;
                    case 0xf3: result += 'ó'; break;
                    case 0xf6: result += 'ö'; break;
                    case 0xfa: result += 'ú'; break;
                    case 0xfc: result += 'ü'; break;
                    case 0xab: result += '«'; break;
                    case 0xbb: result += '»'; break;
                    case 0x0a: result += '¬'; break;
                    default: result += (char)data[i]; break;
                }                   
            }                       
            return result;          
        }                           
    }                               
                                    
    internal class Entry            
    {
        public uint Id { get; set; }
        public int Offset { get; set; }
        public byte[] StringArray { get; set; }
        public string String { get; set; }
    }
}
